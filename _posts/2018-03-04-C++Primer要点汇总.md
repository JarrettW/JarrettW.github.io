---
　　layout: default
　　title: C++Primer要点汇总
---

{{ page.title }}

<h3><strong>第一部分</strong><h3>

<p>1.C++同时支持4+1种不同的编程风格：C风格、基于对象、面向对象和泛型+微软COM"基于组件"的风格</p>

<p>2.一个函数的定义包含四个部分:返回类型,函数名,形参列表及函数体</p>

<p>3.main函数的返回类型必须为int</p>

<p>4.标准输入输出库iostream包含4个IO对象:cin cout cerr clog</p>

<p>5."string literal" : 字符串字面值常量</p>

<p>6.包含来自标准库的头文件时,使用尖括号(< >)包围头文件名. 对于不属于标准库的头文件,则用双引号(" ")包围</p>

<p>7.点运算符(.)左侧运算对象必须是一个类类型的对象,右侧运算对象必须是该类型的一个成员名</p>

<p>8.类(class): 用于定义自己的数据结构及其相关操作的机制</p>

<p>9.C++算数类型</p>
  <ul>
    <li>类型          含义          最小尺寸</li>
    <li>bool         布尔类型        未定义</li>
    <li>char          字符           8位</li>
    <li>wchar_t      宽字符         16位</li>
    <li>char16_t     Unicode字符    16位</li>
    <li>char32_t     Unicode字符    32位</li>
    <li>short        短整型         16位</li>
    <li>int           整型          16位</li>
    <li>long         长整型        32位</li>
    <li>long long    长整型        64位</li>
    <li>float       单精度浮点数    6位有效数字</li>
    <li>double      双精度浮点数    10位有效数字</li>
    <li>long double  扩展精度浮点数 10位有效数字</li>
  </ul>

<p>10.带符号和无符号类型: 无符号类型在类型前加unsigned</p>
    <ul>
        <li>当明确知晓数值不可能为负时,选用无符号类型</li>
        <li>使用int执行整数运算,在实际应用中,short常常显得太小而long一般和int有一样的尺寸.如果你的数值超过了int的表示范围,选用long long</li>
        <li>在算数表达式中不要使用char和bool,因为类型char在有些机器上是有符号的有些是无符号的.
            如果使用一个不大的整数,要明确指定他的类型singed char或者unsigned char</li>
        <li>执行浮点运算选用double,这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几.而且在某些机器来说,双精度运算甚至比单精度还快</li>
    </ul>

<p>11.类型转换</p>
    <ul>
        <li>当把一个非布尔类型的算术值赋给布尔类型时,初始值为0则结果为false,否则结果为true</li>
        <li>当把一个布尔值赋给非布尔类型时,初始值为false则结果为0,初始值为true则结果为1</li>
        <li>当把一个浮点数赋给整数类型时,结果仅保留小数点之前的数值</li>
        <li>当把一个整数赋给浮点数类型时,小数部分记为0.如果该整数所占空间超过了浮点类型的容量,精度可能有损失</li>
        <li>当我们赋给无符号类型一个超出它所表示范围的值时,结果是初始值对无符号类型表示数值总数取模后的余数</li>
        <li>当我们赋给带符号类型一个超出它表示范围的值时,结果是未定义的.此时,程序可能停止工作,可能崩溃,可能生成垃圾数据</li>
    </ul>

<p>12.在一个表达式里,切勿混用带符号类型和无符号类型</p>

<p>13.字符和字符串字面值<br>
    字符串字面值的实际类型是由常量字符构成的数组(array).编译器在每个字符串的结尾处添加一个空字符('\0'),因此,字符串字面值的实际长度要比它的内容多1
    例如,字面值'A'表示的就是单独的字符A, 而字符串"A"则代表了一个字符的数组,该数组包含两个字符:一个是字母A,另一个是空字符
</p>

<p>14.转义序列</p>
    <ul>
        <li>换行符 \n              横向制表符\t             报警(响铃)符\a</li>
        <li>纵向制表符\v           退格符\b                 双引号\"</li>
        <li>反斜线\\               问号\?                  单引号\'</li>
        <li>回车符\r               进纸符\f</li>
    </ul>

<p>15.复合类型</p>
    <p>1.引用: "右值引用(rvalue reference)"主要用于内置类, 当使用术语"引用(reference)"时,指的是"左值引用(lvalue reference)"
    <p>引用必须被初始化; 定义引用时,程序把引用和变量的初始值绑定,而不是将初始值拷贝给引用.一旦初始化完成,引用将和
    它的初始值对象绑定在一起,因为无法令引用重新绑定到另外一个对象,因此引用必须初始化</p>
    <p>定义了引用之后,对其进行的所有操作都是在与之绑定的对象上进行, 引用即别名</p>
    <p>引用的类型必须与其所引用对象的类型一致</p>
    <p>2.指针(pointer)</p>
    <p>指针的类型必须与其所引用对象的类型一致</p>
    <p>指针是"指向"另外一种类型的复合类型</p>
    <p>a.指针本身是一个对象,允许对指针赋值和拷贝,而且在指针的生命周期内,它可以指向几个不同的对象</p>
    <p>b.指针无需在定义时赋初值, 然而在块作用域内定义的指针如果没有被初始化,也将拥有一个不确定的值</p>
    <p>c.指针存放某个对象的地址, 使用&(取址操作符)获取对象地址</p>
    <p>注意:不能定义指向引用的指针</p>
    <p>利用指针访问对象: 如果指针确实指向了一个对象,则允许使用解引用符(*)来访问该对象(可赋值)</p>
    <p>空指针(null pointer):不指向任何对象,在使用一个指针之前代码首先检查是否为空, 使用nullptr和0来初始化空指针(c++11); NULL(cstdlib,预处理器来给指针赋值)</p>
    <p>指向指针的指针: int *pi = &ival;  int **pi = &pi</p>
    <p>指向指针的引用: 不能定义指向引用的指针.int *p = nullptr; int *&r = p;</p>
    <ol>
        <li>指向const(常量)的指针</li>
        <li>const指针:a.指向普通对象的常量指针; b.指向常量对象的常量指针</li>
        <li>用名词顶层const(top-level const)表示指针本身是个常量, 而底层const(low-level const)表示指针所指的对象是一个常量</li>
    </ol>
    <p>constexpr和常量表达式: 常量表达式指值不会改变并且在编译过程中就能得到结果的表达式, 运行时才能获得具体值的表达式不是常量表达式</p>
    <p>C++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式</p>
    <p>eg: constexpr int sz = size();  //只有当size是一个constexpr函数时才是一条正确的声明语句</p>